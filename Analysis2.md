#Analysis

###Design Review

#####Overall Design
- Describe the overall design of the complete program:
    * What is the high level design of each part (front and back end) and how do they work together (i.e., what behavior, data, or resources each part depends on from the others).
      * The front-end components are all displayed through the Controller. The Controller consists of several tabs. Each tab displays the simulation, the toolbar (and its buttons), the current variables, current commands, previous commands, input box, and the preferences sidebar. The simulation keeps track of all the current turtles and their pens and displays them on the field. It also keeps track of the background color. The toolbar keeps track of all of the buttons and displays them at the top of the tab. Each of the buttons can communicate via observers/observables with the back-end and other parts of the front-end. The current variables display is updated whenever new variables are added or when old variables are changed. The previous commands displays all of the previously run commands that the user has entered or loaded from a past file. The current commands displays all of the user-defined commands. The input box allows a user to input slogo commands to move the turtle and perform other behaviors. The input box must send the typed commands to an interpreter, which interprets the input command and executes the command (this is one of the majors ways in which the front end communicates with the back end). The preferences sidebar displays color/image/position preferences of the turtle, the pen, and the background. The user can interact with dynamic updaters in this view in order to update back-end values. 
      * The back-end components are the interpreter and the commands. The interpreter takes in a string input from the input box and produces the corresponding command from it. After it produces this command, it executes it. Executing the command can cause changes in both the front end and the back end. There are many different types of commands--boolean operations, display commands, math operations, multiple turtle commands, turtle commands, turtle queries, etc. Each command class has an execute method which is called by the interpreter to perform some action in the front end/back end.
      * The back-end communicates with the front-end through the input box and the preferences sidebar. The input box takes in a string command, which is sent to the interpreter, which produces the actual command and executes it. Executing a command can perform changes in either the front end or the back end. The preferences sidebar displays dynamic updaters which can update values in the backend and the frontend. For example, a dynamic updater can update the position of the back-end model of the turtle and display these changes in the front-end.
    * Is the code generally consistent in its layout, naming conventions and descriptiveness, and style? Give specific examples for or against by comparing code from each team member.
       * The layout of the code is generally consistent among all team members. For example, in all of the classes, global static variables are initialized at the very beginning of the code and then other private variables are initialized afterwards. For an example, lets look at classes that each team member created--I made SpeedProperty, Jesse made XMLParser, Matt made TurtleCommand, and Maddie made InstructionCleaner. In all four of these classes, the private static global variables are declared at the very beginning of the code, and then other private data is declared. Then, the instructors are the first method declared within the code. There is an inconsistency in when private and public methods are declared within the code. In these examples, it appears that private methods are interspersed between public methods and there isn't any real order. Moreover, for the most part we followed all naming conventions. I did notice, however, that Jesse and Matt tended to use more protected methods than Maddie and I did.
    * What is needed to add one of the following: a new command to the language, a new component to the front end, and a feature from the specification that was not implemented (include all the parts of the code or resources that need to be changed)?
       * New command to the language: Make a commmand class that extends Instruction and implement the execute() method and constructor appropriately. The execute() method takes in an InstructionData object and updates the data within it appropriately. Update the NumArgs.properties, English.properties, and other language properties files to include the new command. The class name should be the same as the name within the resource files so that reflection can be used appropriately. 
       * A new component to the front end: Create a Node (displayable object) and add it to the tabs within main/Controller.java. For buttons within the top toolbar (File, Settings, Help), create a new class which extends tool/Tool.java. Then, add it to the selectionBar within Controller.java. For buttons within the bottom toolbar (play, pause, etc.), make a class which extends tool/ToolButton.java and add it to the selectionBar within Controller.java. Each tab is comprised of a BorderPane. You can add any displayable element to the BorderPane. For example, the variables, commands, previous commands, simulation, inputbox, and preferences sidebar are added to the BorderPane to display them. You can add different front-end elements to the BorderPane if you want to display them. In order to add dynamic updater front-end elements, you add them to the corresponding property classes and then display these within PreferencesView.java.
       * Add the undo button: In order to add the undo button, you can make SimulationView cloneable. Then, whenever SimulationView's step() function is called (meaning that the SimulationView has been updated/a command has been run), you clone the current state of the SimulationView and save it to a stack/array. Whenever the undo button is pressed, set the current SimulationView to the one on the top of the stack and pop it off of the stack.
    * Are the dependencies between the parts clear and easy to find (e.g., public methods and parameters) or do they exist through "back channels" (e.g., static calls, order of method call, sub-class type requirements)?
        * We tried to minimize all static calls. However, there were a few places in the code where order of method call did matter (for example, the constructors of several Parameter files initialize values in a very specific order that otherwise results in a null pointer exception). We also tried to keep subclass type requirements to a minimum. Thus, most of the dependencies in our code are clear and easy to find.
- Describe two components that you did not implement:
     *I will look at Interpreter and Instruction
     * Which is the most readable (i.e., whose classes and methods do what you expect and whose logic is clear and easy to follow)? Give specific examples.
         * I believe Instruction is more readable for two reasons--the comments help explain what each method does and the method names make each method understandable. Most methods in each class are very short (1-10 lines of code) and the logic in them is easy to follow. However, Interpreter has a couple methods (getMyClassifier() and getMyData()) but I don't understand why these methods are needed in the class. It would be helpful if there were comments or better method names to explain why these methods are needed. On the other hand, Instruction has a few methods whose names are ambiguous (getMyText(), getArgumentString(), getArgumentsDouble()), but it has comments to explain why the methods are needed. Thus, while both Interpreter and Instruction both have ambiguous methods, Instruction does a better job of explaining why those methods are needed.
     * Which is the most encapsulated (i.e., whose implementation you feel can be most easily changed without affecting the rest of the program)? Give specific examples.
         * I feel that Instruction is the most encapsulated because it has less dependencies than Interpreter and changing it will affect the program before a changed Instruction would. I feel that Instruction has less dependencies because it only really depends on InstructionData, while Interpreter depends on both InstructionData and InstructionClassifier. Thus, if an incorrect InstructionData object is passed to either one of these classes, they will both fail. However, Interpreter will also fail when it makes an incorrect InstructionClassifier. Moreover, Interpreter depends directly on Instruction while Instruction doesn't depend on Interpreter at all. Also, if you were to change both Interpreter and Instruction, the program would fail due to the changed Interpreter before it would fail due to the changed Instruction. This means that Interpreter affects the program before Instruction, making it less encapsulated (it is not a leaf class). Thus, in my opinion, Instruction is the most encapsulated because it is almost a leaf class and it has less dependencies than Interpreter.
     * What have you learned about design (either good or bad) by reading your team mates' code?
         * Classes that are leaf classes are more encapsulated. Changing classes at the top of a class hierarchy will have dramatic consequences on child classes. It is important to decrease dependencies as much as possible to make classes more encapsulated. Finally, adding lots of useful comments, making good method names, and making code flow together well is very important for readability.
         
#####Your Design
- Describe how your code is designed at a high level (focus on how the classes relate to each other through behavior (methods) rather than their state (instance variables)).
    * The code that I had the most impact in creating are the Controller, buttons/tools (with Jesse), SelectionToolBar, ActorView, TurtleView, PenView, SimulationView, TurtleCommands, Properties classes, and the PreferencesView. The Controller is designed so as to act between the front-end and the back-end. The Controller keeps track of every tab and adds new tabs when a user requests them. Each tab contains the simulation, the toolbar (and its buttons), the current variables, current commands, previous commands, input box, and the preferences sidebar. The main way in which the Controller interacts between the front-end and the back-end is with the InputBox. Whenever the user inputs something into the InputBox and presses enter, the Controller is what sends the input string value to the Interpreter, and the interpreter then converts the string input to an actual command and executes it based on values that are contained within the Controller (simulationview, etc.). The buttons/tools are displayed in the SelectionToolBar at the top of a tab. The buttons can be used to save/open .logo files, change background colors/actor images, open the help page, play/pause the animation, and add/delete actors. These buttons can either be contained within drop-down menus (MenuTool) or clickable buttons (ToolButton). The ActorView class defines all of the properties of an actor (position, heading, etc.), has a method of displaying the actor (display()), and keeps track of the animation stack (SequentialTransition). The SequentialTransition works as an animation stack because you can add animations to it and then remove them whenever they have been run. ActorViews are displayed within SimulationView and new ActorViews can be added through a command or by clicking a button. TurtleView extends ActorView and represents an ActorView which contains a pen. The TurtleView class keeps track of a PenView class. The PenView class has several properties which defines if the pen is up, down, color, size, etc. Moreover, the PenView has its own animation stack to keep track of pen animations when an actor has moved. The PenView, ActorView, and TurtleView classes have a number of properties. The properties classes define dynamic updaters (which can be displayed with a JavaFX node) so that values (like position, heading, color, etc.) can be updated through the GUI. The PreferencesView displays all of these dynamic updaters so that users can change the values. Moreover, the Properties classes define methods to convert xml to a value or from a value to xml (we never got around to actually implementing it in code, but it was added to show extendability). The SimulationView keeps track of multiple turtles, their pens, and the background color. Finally, I implemented almost all of the TurtleCommands, which change features of the Turtle like position and heading. These commands are created and executed in the Interpreter after the user has input a command in the InputBox.
- Describe two features that you implemented in detail â€” one that you feel is good and one that you feel could be improved: 
    * I feel that the Properties classes are good, and the ActorView class could be improved.
        * Justify why the code is designed the way it is or what issues you wrestled with that made the design challenging.
           * The Property class is defined so that it is easy to create a value from xml and convert it to xml. This can be done with the convertToXml() and the setValue(String) methods. Moreover, it makes it easy to display the Property's values graphically (with the display() method) and create dynamic updaters to change the values through the GUI (with the makeDynamicUpdaters()) method. Finally, the Property class has a getValue(T) and setValue(T) method for setting the value of a Property. I designed the class this way so that the GUI representation is created in the same class that the value is contained. This reduces dependencies and encompasses the front-end and back-end aspects of a property in one file. However, I'm still not sure if this design is justified because it kind of mixes a little bit of front-end (dynamic updaters, display, XML) with the back-end.
        * The ActorView class can be improved because it has no differentiation between front-end and back-end properties. This class contains the ImageProperty and ImageColorProperty (which I consider to be front-end propeties) while it also contains the ActorPositionProperty and HeadingProperty (which I consider to be back-end properties). Thus, actors don't have a Model-View architecture, which I believe could be bad design.
      * Are there any assumptions or dependencies from this code that impact the overall design of the program? If not, how did you hide or remove them?
            * The Property class depends on the xml parsing to work and it expects the xml file to have the same name as the Property's name. Moreover, the property class assumes that every property must be created from xml. However, by updating the inheritence hierarchy, this assumption can be removed.
          * The ActorView class depends on all of the Properties classes to work. Moreover, some of an ActorViews propeties depend directly on the ActorView (ActorPositionProperty and HeadingProperty both have constructors which require the ActorView to be passed to it), and this is a bad dependency in general.

#####Flexibility

- Describe what you think makes design more flexible (i.e., able to support adding similar features easily) and how you think this is reflected (or not) in the project's design.
    * I think that abstraction, encapsulation, class hierarchies, and design patterns make design more flexible. Abstraction/Class Hierarchies defines methods that subclasses must use and reduces the amount of code that is reused. For example, many of the Buttons that we implemented only had the purpose of updating a color. Therefore, by making an abstract ColorButton class, we could extend it and reuse many of the same methods (opening a colorpicker and notifying observers when a new color has been chosen) without re-writing code. Thus, if a user wants to change the color of something else, all they need to do is make a button class which extends ColorButton and then display it; this makes it much easier to add a similar feature. Encapsulation ensures that there are no major dependencies between parts of the code. This is important so that changing one class doesn't mess up the entire project. This makes the design more flexible because if you can only add a feature by changing a part of some class, you don't want the whole project to crash because of it. By reducing the dependencies, you reduce the likelihood that this will happen. I believe this is reflected in the project's design through the Tool, SimulationView, PreferencesView, InputBox, Interpreter, and Instruction classes because these classes tried to minimize all dependencies and encapsulate everything into their own class. Design patterns make code more flexible because they are intended to maximize encapsulation and maximize abstraction between different parts of the code. The main way in which we implemented design patterns is through the Interpreter class, which follows the Interpreter design pattern.
- Describe two features from the assignment specification that you did not implement in detail:
    * I will look at the Interpreter and Instruction classes.
       * What is interesting about this code (why did you choose it)?
            * The Interpreter class is one of the most important parts of the code in that it produces an actual command from a string input. It behaves as the actual code compiler and executer. The Instruction class defines how a command performs a function on the rest of the project. Instruction classes actually specify what changes when a user enters a command in the InputBox.
       * What classes or resources are required to implement this feature?
           * Instruction requires InstructionData in order to work. Moreover, the runListCommands method in Instruction depends on the Interpreter. InstructionData also depends on SimulationView, VariableData, and FunctionData. Interpreter depends on InstructionData, InstructionClassifier, TreeBuilder, InstructionCleaner, Pair, and TreeExecuter. Interpreter also depends on the Brackets, Groupings, JavaSpeak, and NumArgs properties files.
       * Describe the design of this feature in detail (what parts are closed? what implementation details are encapsulated? what assumptions are made? do they limit its flexibility?)
           * All of the methods in Instruction are either public or protected, however we were warned against the use of protected methods. I believe that the protected methods within Instruction could be refactored to either make them public or private. Moreover, the private instance variables instructionData and myText are open because they can be gotten with getter methods. This assumes that nobody is going to get them and change their data, but it doesn't limit the flexibility greatly.
           * There is a mix of private and public methods in Interpreter. The private instance variables myData and myClassifier can both be accessed through getter methods, which assumes that nobody is going to get them and change their data. This hardly limits the flexibility, though.
       * How extensible is the design of this feature (is it clear how to extend the code as designed? what kind of change might be hard given this design?)
           * It is relatively clear to see how you would extend Instruction in order to add a new command to the compiler. The only unclear part is that you need to parse InstructionData in the execute() method in order to perform the function that you want. From the Instruction class you can tell that you implement an Instruction by creating a class which has an execute() method which manipulates InstructionData in some manner. Given this design, it might be hard to make a command which affects how a different command works (if there was an opposite command which makes all commands work the opposite of how they typically do--forward goes backwards. right goes left, etc.)
           * The Interpreter class is very clear to use. By simply giving it a string, it compiles it and runs the appropriate command. Given this design and the fact that the parseAndRun(String) method takes in a string as an argument, there isn't really a change that would be hard to implement with this design) since all methods will be represented as Strings and invalid Strings do nothing. I suppose if you changed the input from a String to something else (like an Image), it would be difficult to implement, but I doubt any change like that would occur.


#####Alternate Designs

- Describe how well (or poorly) the original design handled the project's extensions to the original specifications and how these changes were discussed and decisions ultimately made.
    * Seeing the state of the turtle was made easy by the Property's display() method or by calling Property.getValue(). Seeing the palette of images/colors was relatively easy because we could simply add them to the preferences sidebar and then update them whenever the user added a new color. Set/save/load workspace preferences was done by updating the default.xml file to the new values and then loading them on startup. Creating multiple workspaces was simply done by making a TabPane and adding tabs to it within the Controller class. Each tab contained the required views for displaying and dynamically updating the simulation. The sidebar allowed users to change properties of selected turtles. Moreover, the sidebar allowed the user to move the current turtle by updating its position. It also allowed the user to change the pen's properties. Finally for the front-end, the animations were added within the ActorView class itself. The ActorView class essentially had a stack of animations that were currently being run and it popped each one off after it was finished running. We also added buttons to the toolbar to support pausing and starting the animation, and added an FPS slider to the sidebar to control the speed of the animation. We didn't implement the undo button or debugger largely because of a lack of time. I believe our design could have handled the undo button relatively well if we had made SimulationView cloneable. With this design, Controller could save a stack of SimulationViews and add a clone of the current SimulationView to this stack everytime a new command is run. Then, if the user wishes to undo something, the controller updates the current SimulationView to one popped off of the stack. The debugger also would have been relatively easy if we made another button for allowing the user to step through each animation (like a step button that only plays one animation within the stack at a time)
    * While I didn't design the back-end, I heard that many of the extensions worked very well with the design that we had after sprint 2. The only major change that was needed was with recursion. The additional commands followed the same structure as previously added commands, but a few new objects were added to InstructionData to support changing colors/images/multiple turtles with a command.
- Describe two design decisions discussed about any part of the program in detail:
    * Using a tree for parsing input commands.
    * Using Property classes within ActorView, SimulationView, and PenView
      * What alternate designs were proposed?
          * Instead of using a tree, some group members thought it would be better to use a stack instead.
          * Instead of using Property classes, some group members thought it would be better to have views for abstract-updaters and separate xml classes for parsing/saving xml.
      * What are the trade-offs of all the design choices (describe the pros and cons of the different designs)?
          * Using a tree makes it simpler to keep track of the parameters for a given command, but it can be difficult to understand how the command will be parsed through postfix notation. Moreover, it is relatively complex to add parameter children to the tree. Using a stack is reminiscent of the Java compiler (with stack overflows), and it is very easy to add children because you simply push them to the stack before you push the command. However, stacks are also difficult to understand because some commands have multiple parameters and its hard to keep track of how many elements to pop off.
          * Using property classes keeps the GUI, xml, and back-end value portions of a property in the same class. This makes the property very encapsulated and it doesn't really have dependencies outside of the Property class. However, the Property class mixes the back-end and front-end together and doesn't really follow the MVC design pattern. By keeping the dynamic updater/xml in the front-end and the actual property value in the back-end, you make it more difficult for the front-end to communicate with the backend, but this does keep the front- and back-ends fairly distinct, which follows the MVC design pattern.
     * Which would you prefer and why (it does not have to be the one that is currently implemented)?
         * I prefer using the tree because it makes it easy to keep track of all of a command's children and it makes the design neater. Moreover, it is easier to parse through the tree than it is to parse through a stack.
         * I prefer using the Property class instead of keeping dynamic updaters/xml in the front-end and values in the back-end. I prefer this because it allows for better encapsulation and is more flexible in my opinion, since you only need to make a new Property class in order to add these things to the program. 


#####Conclusions


- Describe the best feature of the project's current design and what did you learn from reading or implementing it?
    * I believe the best feature of the project's current design is the TreeBuilder and its interaction with the Instruction class. The TreeBuilder creates a Tree where each node is an instruction and its children are its parameters. The tree can have as many children as is necessary. Then, the tree is evaluated with postfix notation and recursively updated as each node is executed. By reading this class, I learned the algorithm for using a tree to compile code and learned about the efficiency of this process.
- Describe the worst feature that remains in the project's current design and what did you learn from reading or implementing it?
    * I believe the worst feature that remains in the project's current design is the way that buttons are currently designed. It is poor design because you need to define a new Button class for every button that is displayed. This can be seen within SettingsMenuTool.java, where you can see that we need to make a nested class for DefaultButton, LanguageButton, PenColorButton, TurtleImageButton, and BackgroundColor button. From this, I learned that lambda functions can be very useful when this type of bad code appears, as you don't have to make a new class definition for every type of button.
- To be a better designer in the next project, what should you
     * start doing differently
         * For the next project, I need to hard to start using more design patterns so I can ensure that my code is designed well. In this project, I found it hard to justify my design decisions when there wasn't a design pattern to back them up. Moreover, I need to understand the advanced concepts like lambda functions and function programming/streams better so that I can make my code more condensed and also more readable.
     * keep doing the same
         * For the next project, I should keep implementing generics, encapsulating my classes, using abstraction and class hierarchies, and begin working on the project early. Moreover, I should continue changing bad code whenever I see it and communicating with team members whenever I see a potential design flaw.
     * stop doing
         * For the next project, I should stop being hesitant about committing code. I need to commit code everytime I make a change of any kind. Moreover, I need to stop writing code on the last day that the project is due. There needs to be a cut-off time of implementing code so that no bad code is introduced at the last minute. Finally, I should stop only focussing on the front-end--I believe it is important to communicate with all parts of the team so that I understand the project as a whole and can offer feedback on design specifications.

